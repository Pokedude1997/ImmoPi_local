
import { 
  Property, Counterparty, Category, AppDocument, Transaction, RecurringPayment, AppSettings, 
  CategoryType, PropertyType, DocumentType, CounterpartyType, Tenant
} from '../types';

// Initial Data Seeding
const DEFAULT_CATEGORIES: Category[] = [
  { id: 'c1', name: 'Rent (Warm)', type: CategoryType.INCOME, isTaxRelevant: true },
  { id: 'c2', name: 'Rent (Cold)', type: CategoryType.INCOME, isTaxRelevant: true },
  { id: 'c11', name: 'Side Costs', type: CategoryType.INCOME, isTaxRelevant: true },
  { id: 'c3', name: 'Maintenance / Repairs', type: CategoryType.EXPENSE, isTaxRelevant: true },
  { id: 'c4', name: 'Hausgeld (HOA Fee)', type: CategoryType.EXPENSE, isTaxRelevant: true },
  { id: 'c5', name: 'Electricity', type: CategoryType.EXPENSE, isTaxRelevant: true },
  { id: 'c6', name: 'Internet/Phone', type: CategoryType.EXPENSE, isTaxRelevant: true },
  { id: 'c7', name: 'Property Tax', type: CategoryType.EXPENSE, isTaxRelevant: true },
  { id: 'c8', name: 'Insurance', type: CategoryType.EXPENSE, isTaxRelevant: true },
  { id: 'c9', name: 'Mortgage Interest', type: CategoryType.EXPENSE, isTaxRelevant: true },
  { id: 'c10', name: 'Mortgage Principal', type: CategoryType.EXPENSE, isTaxRelevant: false },
];

const STORAGE_KEYS = {
  PROPERTIES: 'immopi_properties',
  TENANTS: 'immopi_tenants',
  COUNTERPARTIES: 'immopi_counterparties',
  CATEGORIES: 'immopi_categories',
  DOCUMENTS: 'immopi_documents',
  TRANSACTIONS: 'immopi_transactions',
  RECURRING: 'immopi_recurring',
  SETTINGS: 'immopi_settings',
};

const generateId = () => Math.random().toString(36).substring(2, 9);

const parseLocalDate = (dateStr: string) => {
  const [y, m, d] = dateStr.split('-').map(Number);
  return new Date(y, m - 1, d);
};

class StorageService {
  private get<T>(key: string, defaultVal: T): T {
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : defaultVal;
  }

  private set(key: string, value: any) {
    localStorage.setItem(key, JSON.stringify(value));
  }

  getProperties(): Property[] {
    return this.get<Property[]>(STORAGE_KEYS.PROPERTIES, []);
  }

  saveProperty(item: Omit<Property, 'id'> & { id?: string }): Property {
    const list = this.getProperties();
    let savedProp: Property;
    if (item.id) {
      const idx = list.findIndex(p => p.id === item.id);
      if (idx >= 0) {
        list[idx] = item as Property;
        this.set(STORAGE_KEYS.PROPERTIES, list);
        savedProp = item as Property;
      } else {
        savedProp = { ...item, id: generateId() } as Property;
        list.push(savedProp);
        this.set(STORAGE_KEYS.PROPERTIES, list);
      }
    } else {
      savedProp = { ...item, id: generateId() } as Property;
      list.push(savedProp);
      this.set(STORAGE_KEYS.PROPERTIES, list);
    }
    const settings = this.getSettings();
    this.syncMortgageTransactions(savedProp, settings.taxYear);
    return savedProp;
  }

  deleteProperty(id: string) {
    const list = this.getProperties().filter(i => i.id !== id);
    this.set(STORAGE_KEYS.PROPERTIES, list);
    const txs = this.getTransactions().filter(t => !(t.propertyId === id && t.isAutoGenerated));
    this.set(STORAGE_KEYS.TRANSACTIONS, txs);
  }

  // Tenants
  getTenants(): Tenant[] {
    return this.get<Tenant[]>(STORAGE_KEYS.TENANTS, []);
  }

  saveTenant(item: Omit<Tenant, 'id'> & { id?: string }): Tenant {
    const list = this.getTenants();
    if (item.id) {
      const idx = list.findIndex(p => p.id === item.id);
      if (idx >= 0) {
        list[idx] = item as Tenant;
        this.set(STORAGE_KEYS.TENANTS, list);
        return item as Tenant;
      }
    }
    const newItem = { ...item, id: generateId() } as Tenant;
    list.push(newItem);
    this.set(STORAGE_KEYS.TENANTS, list);
    return newItem;
  }

  deleteTenant(id: string) {
    const list = this.getTenants().filter(i => i.id !== id);
    this.set(STORAGE_KEYS.TENANTS, list);
  }

  getTransactions(): Transaction[] {
    return this.get<Transaction[]>(STORAGE_KEYS.TRANSACTIONS, []);
  }

  saveTransaction(item: Omit<Transaction, 'id'> & { id?: string }): Transaction {
    const list = this.getTransactions();
    if (item.id) {
      const idx = list.findIndex(p => p.id === item.id);
      if (idx >= 0) {
        list[idx] = item as Transaction;
        this.set(STORAGE_KEYS.TRANSACTIONS, list);
        return item as Transaction;
      }
    }
    const newItem = { ...item, id: generateId() } as Transaction;
    list.push(newItem);
    this.set(STORAGE_KEYS.TRANSACTIONS, list);
    return newItem;
  }

  deleteTransaction(id: string) {
    const list = this.getTransactions().filter(i => i.id !== id);
    this.set(STORAGE_KEYS.TRANSACTIONS, list);
  }

  syncMortgageTransactions(property: Property, year: number) {
    let txs = this.getTransactions();
    txs = txs.filter(t => {
      const isMortgageTx = t.categoryId === 'c9' || t.categoryId === 'c10';
      const isAuto = t.isAutoGenerated;
      const sameProp = t.propertyId === property.id;
      const sameYear = new Date(t.date).getFullYear() === year;
      return !(isMortgageTx && isAuto && sameProp && sameYear);
    });
    this.set(STORAGE_KEYS.TRANSACTIONS, txs);

    if (!property.mortgage) return [];
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const { loanAmount, startDate, interestRate, principalRate, bankName, paymentTiming } = property.mortgage;
    const start = parseLocalDate(startDate);
    const annualTotalRate = (interestRate + principalRate) / 100;
    const monthlyPayment = (loanAmount * annualTotalRate) / 12;
    let currentDate = new Date(start.getFullYear(), start.getMonth(), 1);
    let currentBalance = loanAmount;
    const yearEnd = new Date(year, 11, 31);
    const stopAt = today < yearEnd ? today : yearEnd;

    const logs: string[] = [];
    while (currentDate <= stopAt) {
      let paymentDay = 1;
      if (paymentTiming === 'END_OF_MONTH') {
        paymentDay = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0).getDate();
      }
      const paymentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), paymentDay);
      if (paymentDate > stopAt) break;

      const monthInterest = currentBalance * (interestRate / 100 / 12);
      const monthPrincipal = monthlyPayment - monthInterest;
      const dateStr = paymentDate.toISOString().split('T')[0];

      if (paymentDate.getFullYear() === year) {
        this.saveTransaction({
          type: CategoryType.EXPENSE,
          propertyId: property.id,
          categoryId: 'c9',
          amount: monthInterest,
          currency: 'EUR',
          date: dateStr,
          description: `Mortgage Interest: ${property.name} (${bankName || 'Bank'})`,
          isAutoGenerated: true
        });
        this.saveTransaction({
          type: CategoryType.EXPENSE,
          propertyId: property.id,
          categoryId: 'c10',
          amount: monthPrincipal,
          currency: 'EUR',
          date: dateStr,
          description: `Mortgage Principal: ${property.name} (${bankName || 'Bank'})`,
          isAutoGenerated: true
        });
        logs.push(`Generated: ${property.name} ${dateStr.substring(0, 7)}`);
      }
      currentBalance -= monthPrincipal;
      currentDate.setMonth(currentDate.getMonth() + 1);
    }
    return logs;
  }

  getCategories(): Category[] {
    const data = localStorage.getItem(STORAGE_KEYS.CATEGORIES);
    if (data === null) {
      this.set(STORAGE_KEYS.CATEGORIES, DEFAULT_CATEGORIES);
      return DEFAULT_CATEGORIES;
    }
    return JSON.parse(data);
  }

  saveCategory(item: Omit<Category, 'id'> & { id?: string }): Category {
    const list = this.getCategories();
    if (item.id) {
      const idx = list.findIndex(p => p.id === item.id);
      if (idx >= 0) {
        list[idx] = item as Category;
        this.set(STORAGE_KEYS.CATEGORIES, list);
        return item as Category;
      }
    }
    const newItem = { ...item, id: generateId() } as Category;
    list.push(newItem);
    this.set(STORAGE_KEYS.CATEGORIES, list);
    return newItem;
  }

  deleteCategory(id: string) {
    const list = this.getCategories().filter(i => i.id !== id);
    this.set(STORAGE_KEYS.CATEGORIES, list);
  }

  getRecurringPayments(): RecurringPayment[] {
    return this.get<RecurringPayment[]>(STORAGE_KEYS.RECURRING, []);
  }

  saveRecurringPayment(item: Omit<RecurringPayment, 'id'> & { id?: string }): RecurringPayment {
    const list = this.getRecurringPayments();
    if (item.id) {
      const idx = list.findIndex(p => p.id === item.id);
      if (idx >= 0) {
        list[idx] = item as RecurringPayment;
        this.set(STORAGE_KEYS.RECURRING, list);
        return item as RecurringPayment;
      }
    }
    const newItem = { ...item, id: generateId() } as RecurringPayment;
    list.push(newItem);
    this.set(STORAGE_KEYS.RECURRING, list);
    return newItem;
  }

  deleteRecurringPayment(id: string) {
    const list = this.getRecurringPayments().filter(i => i.id !== id);
    this.set(STORAGE_KEYS.RECURRING, list);
  }

  getSettings(): AppSettings {
    return this.get<AppSettings>(STORAGE_KEYS.SETTINGS, {
      googleDriveFolderId: '',
      currency: 'EUR',
      taxYear: new Date().getFullYear(),
    });
  }

  saveSettings(item: AppSettings): AppSettings {
    this.set(STORAGE_KEYS.SETTINGS, item);
    return item;
  }

  getDocuments(): AppDocument[] {
    return this.get<AppDocument[]>(STORAGE_KEYS.DOCUMENTS, []);
  }

  saveDocument(item: Omit<AppDocument, 'id'> & { id?: string }): AppDocument {
    const list = this.getDocuments();
    if (item.id) {
      const idx = list.findIndex(p => p.id === item.id);
      if (idx >= 0) {
        list[idx] = item as AppDocument;
        this.set(STORAGE_KEYS.DOCUMENTS, list);
        return item as AppDocument;
      }
    }
    const newItem = { ...item, id: generateId() } as AppDocument;
    list.push(newItem);
    this.set(STORAGE_KEYS.DOCUMENTS, list);
    return newItem;
  }
}

export const db = new StorageService();
