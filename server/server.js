/**
 * ImmoPi Manager - Complete Backend API
 * 
 * Full REST API with CRUD operations for all entities
 * Frontend communicates exclusively through these endpoints
 */

const express = require('express');
const cors = require('cors');
const sqlite3 = require('sqlite3').verbose();
const multer = require('multer');
const { GoogleGenAI } = require('@google/genai');
const fs = require('fs');
const path = require('path');
const cookieParser = require('cookie-parser');
require('dotenv').config();

const { login, logout, requireAuth } = require('./auth-middleware');
const { performBackup, startBackupScheduler } = require('./backup');
const { validateAndSanitize } = require('./ai-validator');
const { uploadDocument, getDocumentLink, deleteDocument, initializeDriveClient } = require('./drive-storage');

const app = express();
const PORT = process.env.PORT || 8000;

app.use(cors({ origin: process.env.CORS_ORIGIN || '*', credentials: true }));
app.use(express.json());
app.use(cookieParser());

const logsDir = path.join(__dirname, 'logs');
const uploadsDir = path.join(__dirname, 'uploads');
[logsDir, uploadsDir].forEach(dir => {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
});

const db = new sqlite3.Database('./immopi.db', (err) => {
  if (err) console.error('âŒ DB Error:', err.message);
  else console.log('âœ… Connected to SQLite database.');
});

// Create all tables
db.serialize(() => {
  db.run(`CREATE TABLE IF NOT EXISTS properties (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    address TEXT,
    type TEXT,
    purchasePrice REAL,
    purchaseDate TEXT,
    rentAmount REAL,
    size REAL,
    mortgage_loanAmount REAL,
    mortgage_startDate TEXT,
    mortgage_interestRate REAL,
    mortgage_principalRate REAL,
    mortgage_bankName TEXT,
    mortgage_paymentTiming TEXT,
    notes TEXT
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS tenants (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    firstName TEXT NOT NULL,
    lastName TEXT NOT NULL,
    email TEXT,
    phone TEXT,
    property_id INTEGER,
    leaseStart TEXT,
    leaseEnd TEXT,
    rentAmount REAL,
    deposit REAL,
    notes TEXT,
    FOREIGN KEY (property_id) REFERENCES properties(id)
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS categories (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    type TEXT NOT NULL,
    isTaxRelevant INTEGER DEFAULT 0
  )`);

  // Seed default categories if empty
  db.get('SELECT COUNT(*) as count FROM categories', [], (err, row) => {
    if (!err && row.count === 0) {
      const defaultCategories = [
        ['Rent (Warm)', 'INCOME', 1],
        ['Rent (Cold)', 'INCOME', 1],
        ['Side Costs', 'INCOME', 1],
        ['Maintenance / Repairs', 'EXPENSE', 1],
        ['Hausgeld (HOA Fee)', 'EXPENSE', 1],
        ['Electricity', 'EXPENSE', 1],
        ['Internet/Phone', 'EXPENSE', 1],
        ['Property Tax', 'EXPENSE', 1],
        ['Insurance', 'EXPENSE', 1],
        ['Mortgage Interest', 'EXPENSE', 1],
        ['Mortgage Principal', 'EXPENSE', 0],
      ];
      const stmt = db.prepare('INSERT INTO categories (name, type, isTaxRelevant) VALUES (?, ?, ?)');
      defaultCategories.forEach(cat => stmt.run(cat));
      stmt.finalize();
      console.log('âœ… Seeded default categories');
    }
  });

  db.run(`CREATE TABLE IF NOT EXISTS counterparties (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    type TEXT NOT NULL,
    contactPerson TEXT,
    email TEXT,
    phone TEXT,
    address TEXT,
    notes TEXT
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS transactions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    date TEXT NOT NULL,
    amount REAL NOT NULL,
    currency TEXT NOT NULL DEFAULT 'EUR',
    description TEXT,
    type TEXT NOT NULL,
    property_id INTEGER,
    category_id INTEGER,
    counterparty_id INTEGER,
    document_id INTEGER,
    isAutoGenerated INTEGER DEFAULT 0,
    FOREIGN KEY (property_id) REFERENCES properties(id),
    FOREIGN KEY (category_id) REFERENCES categories(id),
    FOREIGN KEY (counterparty_id) REFERENCES counterparties(id),
    FOREIGN KEY (document_id) REFERENCES documents(id)
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS documents (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    file_name TEXT NOT NULL,
    original_name TEXT NOT NULL,
    mime_type TEXT NOT NULL,
    upload_date TEXT NOT NULL,
    document_date TEXT,
    document_type TEXT,
    amount REAL,
    currency TEXT,
    property_id INTEGER,
    category_id INTEGER,
    counterparty_id INTEGER,
    notes TEXT,
    google_drive_id TEXT,
    google_drive_path TEXT,
    ai_analysis_raw TEXT,
    FOREIGN KEY (property_id) REFERENCES properties(id)
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS recurring_payments (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    amount REAL NOT NULL,
    currency TEXT DEFAULT 'EUR',
    frequency TEXT NOT NULL,
    startDate TEXT NOT NULL,
    endDate TEXT,
    category_id INTEGER,
    property_id INTEGER,
    counterparty_id INTEGER,
    isActive INTEGER DEFAULT 1,
    FOREIGN KEY (category_id) REFERENCES categories(id),
    FOREIGN KEY (property_id) REFERENCES properties(id),
    FOREIGN KEY (counterparty_id) REFERENCES counterparties(id)
  )`);

  db.run(`CREATE TABLE IF NOT EXISTS settings (
    id INTEGER PRIMARY KEY CHECK (id = 1),
    currency TEXT DEFAULT 'EUR',
    taxYear INTEGER DEFAULT 2026,
    googleDriveFolderId TEXT
  )`);

  // Seed default settings
  db.get('SELECT * FROM settings WHERE id = 1', [], (err, row) => {
    if (!err && !row) {
      db.run('INSERT INTO settings (id, currency, taxYear) VALUES (1, "EUR", 2026)');
    }
  });
});

// ============================================================================
// AUTHENTICATION
// ============================================================================

app.post('/api/auth/login', async (req, res) => {
  const { password } = req.body;
  if (!password) return res.status(400).json({ error: 'Password required' });
  
  const result = await login(password);
  if (result.success) {
    res.cookie('sessionToken', result.token, {
      httpOnly: true,
      maxAge: 24 * 60 * 60 * 1000,
      sameSite: 'strict',
    });
    res.json({ success: true, token: result.token, expiresAt: result.expiresAt });
  } else {
    res.status(401).json({ error: result.error });
  }
});

app.post('/api/auth/logout', (req, res) => {
  const token = req.headers.authorization?.replace('Bearer ', '') || req.cookies?.sessionToken;
  logout(token);
  res.clearCookie('sessionToken');
  res.json({ success: true });
});

app.get('/api/auth/check', requireAuth, (req, res) => {
  res.json({ authenticated: true });
});

// ============================================================================
// PROPERTIES CRUD
// ============================================================================

app.get('/api/properties', requireAuth, (req, res) => {
  db.all('SELECT * FROM properties', [], (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(rows);
  });
});

app.get('/api/properties/:id', requireAuth, (req, res) => {
  db.get('SELECT * FROM properties WHERE id = ?', [req.params.id], (err, row) => {
    if (err) return res.status(500).json({ error: err.message });
    if (!row) return res.status(404).json({ error: 'Property not found' });
    res.json(row);
  });
});

app.post('/api/properties', requireAuth, (req, res) => {
  const { name, address, type, purchasePrice, purchaseDate, rentAmount, size, mortgage, notes } = req.body;
  const m = mortgage || {};
  
  db.run(
    `INSERT INTO properties (name, address, type, purchasePrice, purchaseDate, rentAmount, size,
      mortgage_loanAmount, mortgage_startDate, mortgage_interestRate, mortgage_principalRate,
      mortgage_bankName, mortgage_paymentTiming, notes)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
    [name, address, type, purchasePrice, purchaseDate, rentAmount, size,
      m.loanAmount, m.startDate, m.interestRate, m.principalRate, m.bankName, m.paymentTiming, notes],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ id: this.lastID });
    }
  );
});

app.put('/api/properties/:id', requireAuth, (req, res) => {
  const { name, address, type, purchasePrice, purchaseDate, rentAmount, size, mortgage, notes } = req.body;
  const m = mortgage || {};
  
  db.run(
    `UPDATE properties SET name=?, address=?, type=?, purchasePrice=?, purchaseDate=?, rentAmount=?, size=?,
      mortgage_loanAmount=?, mortgage_startDate=?, mortgage_interestRate=?, mortgage_principalRate=?,
      mortgage_bankName=?, mortgage_paymentTiming=?, notes=?
    WHERE id=?`,
    [name, address, type, purchasePrice, purchaseDate, rentAmount, size,
      m.loanAmount, m.startDate, m.interestRate, m.principalRate, m.bankName, m.paymentTiming, notes, req.params.id],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      if (this.changes === 0) return res.status(404).json({ error: 'Property not found' });
      res.json({ success: true });
    }
  );
});

app.delete('/api/properties/:id', requireAuth, (req, res) => {
  db.run('DELETE FROM properties WHERE id = ?', [req.params.id], function(err) {
    if (err) return res.status(500).json({ error: err.message });
    res.json({ success: true });
  });
});

// ============================================================================
// TENANTS CRUD
// ============================================================================

app.get('/api/tenants', requireAuth, (req, res) => {
  db.all('SELECT * FROM tenants', [], (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(rows);
  });
});

app.post('/api/tenants', requireAuth, (req, res) => {
  const { firstName, lastName, email, phone, property_id, leaseStart, leaseEnd, rentAmount, deposit, notes } = req.body;
  db.run(
    'INSERT INTO tenants (firstName, lastName, email, phone, property_id, leaseStart, leaseEnd, rentAmount, deposit, notes) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
    [firstName, lastName, email, phone, property_id, leaseStart, leaseEnd, rentAmount, deposit, notes],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ id: this.lastID });
    }
  );
});

app.put('/api/tenants/:id', requireAuth, (req, res) => {
  const { firstName, lastName, email, phone, property_id, leaseStart, leaseEnd, rentAmount, deposit, notes } = req.body;
  db.run(
    'UPDATE tenants SET firstName=?, lastName=?, email=?, phone=?, property_id=?, leaseStart=?, leaseEnd=?, rentAmount=?, deposit=?, notes=? WHERE id=?',
    [firstName, lastName, email, phone, property_id, leaseStart, leaseEnd, rentAmount, deposit, notes, req.params.id],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ success: true });
    }
  );
});

app.delete('/api/tenants/:id', requireAuth, (req, res) => {
  db.run('DELETE FROM tenants WHERE id = ?', [req.params.id], function(err) {
    if (err) return res.status(500).json({ error: err.message });
    res.json({ success: true });
  });
});

// ============================================================================
// CATEGORIES CRUD
// ============================================================================

app.get('/api/categories', requireAuth, (req, res) => {
  db.all('SELECT * FROM categories', [], (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(rows);
  });
});

app.post('/api/categories', requireAuth, (req, res) => {
  const { name, type, isTaxRelevant } = req.body;
  db.run('INSERT INTO categories (name, type, isTaxRelevant) VALUES (?, ?, ?)',
    [name, type, isTaxRelevant ? 1 : 0],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ id: this.lastID });
    }
  );
});

app.put('/api/categories/:id', requireAuth, (req, res) => {
  const { name, type, isTaxRelevant } = req.body;
  db.run('UPDATE categories SET name=?, type=?, isTaxRelevant=? WHERE id=?',
    [name, type, isTaxRelevant ? 1 : 0, req.params.id],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ success: true });
    }
  );
});

app.delete('/api/categories/:id', requireAuth, (req, res) => {
  db.run('DELETE FROM categories WHERE id = ?', [req.params.id], function(err) {
    if (err) return res.status(500).json({ error: err.message });
    res.json({ success: true });
  });
});

// ============================================================================
// TRANSACTIONS CRUD
// ============================================================================

app.get('/api/transactions', requireAuth, (req, res) => {
  db.all('SELECT * FROM transactions ORDER BY date DESC', [], (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(rows);
  });
});

app.post('/api/transactions', requireAuth, (req, res) => {
  const { date, amount, currency, description, type, property_id, category_id, counterparty_id, document_id } = req.body;
  db.run(
    'INSERT INTO transactions (date, amount, currency, description, type, property_id, category_id, counterparty_id, document_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
    [date, amount, currency || 'EUR', description, type, property_id, category_id, counterparty_id, document_id],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ id: this.lastID });
    }
  );
});

app.put('/api/transactions/:id', requireAuth, (req, res) => {
  const { date, amount, currency, description, type, property_id, category_id, counterparty_id, document_id } = req.body;
  db.run(
    'UPDATE transactions SET date=?, amount=?, currency=?, description=?, type=?, property_id=?, category_id=?, counterparty_id=?, document_id=? WHERE id=?',
    [date, amount, currency, description, type, property_id, category_id, counterparty_id, document_id, req.params.id],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ success: true });
    }
  );
});

app.delete('/api/transactions/:id', requireAuth, (req, res) => {
  db.run('DELETE FROM transactions WHERE id = ?', [req.params.id], function(err) {
    if (err) return res.status(500).json({ error: err.message });
    res.json({ success: true });
  });
});

// ============================================================================
// COUNTERPARTIES CRUD
// ============================================================================

app.get('/api/counterparties', requireAuth, (req, res) => {
  db.all('SELECT * FROM counterparties', [], (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(rows);
  });
});

app.post('/api/counterparties', requireAuth, (req, res) => {
  const { name, type, contactPerson, email, phone, address, notes } = req.body;
  db.run(
    'INSERT INTO counterparties (name, type, contactPerson, email, phone, address, notes) VALUES (?, ?, ?, ?, ?, ?, ?)',
    [name, type, contactPerson, email, phone, address, notes],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ id: this.lastID });
    }
  );
});

app.put('/api/counterparties/:id', requireAuth, (req, res) => {
  const { name, type, contactPerson, email, phone, address, notes } = req.body;
  db.run(
    'UPDATE counterparties SET name=?, type=?, contactPerson=?, email=?, phone=?, address=?, notes=? WHERE id=?',
    [name, type, contactPerson, email, phone, address, notes, req.params.id],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ success: true });
    }
  );
});

app.delete('/api/counterparties/:id', requireAuth, (req, res) => {
  db.run('DELETE FROM counterparties WHERE id = ?', [req.params.id], function(err) {
    if (err) return res.status(500).json({ error: err.message });
    res.json({ success: true });
  });
});

// ============================================================================
// RECURRING PAYMENTS CRUD
// ============================================================================

app.get('/api/recurring-payments', requireAuth, (req, res) => {
  db.all('SELECT * FROM recurring_payments', [], (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(rows);
  });
});

app.post('/api/recurring-payments', requireAuth, (req, res) => {
  const { name, amount, currency, frequency, startDate, endDate, category_id, property_id, counterparty_id, isActive } = req.body;
  db.run(
    'INSERT INTO recurring_payments (name, amount, currency, frequency, startDate, endDate, category_id, property_id, counterparty_id, isActive) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
    [name, amount, currency || 'EUR', frequency, startDate, endDate, category_id, property_id, counterparty_id, isActive ? 1 : 0],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ id: this.lastID });
    }
  );
});

app.put('/api/recurring-payments/:id', requireAuth, (req, res) => {
  const { name, amount, currency, frequency, startDate, endDate, category_id, property_id, counterparty_id, isActive } = req.body;
  db.run(
    'UPDATE recurring_payments SET name=?, amount=?, currency=?, frequency=?, startDate=?, endDate=?, category_id=?, property_id=?, counterparty_id=?, isActive=? WHERE id=?',
    [name, amount, currency, frequency, startDate, endDate, category_id, property_id, counterparty_id, isActive ? 1 : 0, req.params.id],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ success: true });
    }
  );
});

app.delete('/api/recurring-payments/:id', requireAuth, (req, res) => {
  db.run('DELETE FROM recurring_payments WHERE id = ?', [req.params.id], function(err) {
    if (err) return res.status(500).json({ error: err.message });
    res.json({ success: true });
  });
});

// ============================================================================
// SETTINGS
// ============================================================================

app.get('/api/settings', requireAuth, (req, res) => {
  db.get('SELECT * FROM settings WHERE id = 1', [], (err, row) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(row || { currency: 'EUR', taxYear: 2026, googleDriveFolderId: '' });
  });
});

app.put('/api/settings', requireAuth, (req, res) => {
  const { currency, taxYear, googleDriveFolderId } = req.body;
  db.run(
    'UPDATE settings SET currency=?, taxYear=?, googleDriveFolderId=? WHERE id=1',
    [currency, taxYear, googleDriveFolderId],
    function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ success: true });
    }
  );
});

// ============================================================================
// DOCUMENTS
// ============================================================================

app.get('/api/documents', requireAuth, (req, res) => {
  db.all('SELECT d.*, p.name as property_name FROM documents d LEFT JOIN properties p ON d.property_id = p.id ORDER BY d.upload_date DESC', [], (err, rows) => {
    if (err) return res.status(500).json({ error: err.message });
    res.json(rows.map(doc => ({ ...doc, driveLink: doc.google_drive_id ? getDocumentLink(doc.google_drive_id) : null })));
  });
});

app.get('/api/documents/:id', requireAuth, (req, res) => {
  db.get('SELECT d.*, p.name as property_name FROM documents d LEFT JOIN properties p ON d.property_id = p.id WHERE d.id = ?', [req.params.id], (err, row) => {
    if (err) return res.status(500).json({ error: err.message });
    if (!row) return res.status(404).json({ error: 'Document not found' });
    row.driveLink = row.google_drive_id ? getDocumentLink(row.google_drive_id) : null;
    res.json(row);
  });
});

app.delete('/api/documents/:id', requireAuth, async (req, res) => {
  try {
    const doc = await new Promise((resolve, reject) => {
      db.get('SELECT google_drive_id FROM documents WHERE id = ?', [req.params.id], (err, row) => {
        if (err) reject(err);
        else resolve(row);
      });
    });

    if (!doc) return res.status(404).json({ error: 'Document not found' });

    // Delete from Google Drive
    if (doc.google_drive_id) {
      await deleteDocument(doc.google_drive_id);
    }

    // Delete from database
    db.run('DELETE FROM documents WHERE id = ?', [req.params.id], function(err) {
      if (err) return res.status(500).json({ error: err.message });
      res.json({ success: true });
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

const upload = multer({ dest: uploadsDir });

function logAIFailure(fileName, errorType, details) {
  const timestamp = new Date().toISOString();
  const logEntry = `${timestamp} | ${fileName} | ${errorType} | ${JSON.stringify(details)}\n`;
  const logFile = path.join(logsDir, `ai-failures-${new Date().toISOString().split('T')[0]}.log`);
  fs.appendFileSync(logFile, logEntry);
}

async function retryWithBackoff(fn, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxRetries) throw error;
      const backoffMs = Math.pow(2, attempt - 1) * 1000;
      console.log(`âš ï¸  Retry ${attempt}/${maxRetries} after ${backoffMs}ms...`);
      await new Promise(resolve => setTimeout(resolve, backoffMs));
    }
  }
}

app.post('/api/documents/analyze', requireAuth, upload.single('file'), async (req, res) => {
  if (!req.file) return res.status(400).json({ error: 'No file uploaded' });

  const fileName = req.file.originalname || req.file.filename;
  console.log(`\nðŸ“„ Processing: ${fileName}`);
  
  let driveFileId = null;

  try {
    // AI Analysis
    if (!process.env.API_KEY) throw new Error('API_KEY not configured');
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    const fileBuffer = fs.readFileSync(req.file.path);
    const base64Data = fileBuffer.toString('base64');
    
    const response = await retryWithBackoff(async () => {
      return await ai.models.generateContent({
        model: 'gemini-2.5-flash-preview',
        contents: {
          parts: [
            { inlineData: { mimeType: req.file.mimetype, data: base64Data } },
            { text: "Extract: date (ISO), amount (number), currency (CHF/EUR/USD), documentType (Invoice/Receipt/Contract/Utility Bill/Tax Statement/Other). JSON only." }
          ]
        },
        config: { responseMimeType: "application/json" }
      });
    });

    const parsedResponse = JSON.parse(response.text);
    const validationResult = validateAndSanitize(parsedResponse);
    const aiData = validationResult.success ? validationResult.data : parsedResponse;

    // Upload to Drive
    const propertyId = req.body.propertyId;
    let propertyName = 'Unassigned';
    if (propertyId) {
      const property = await new Promise((resolve, reject) => {
        db.get('SELECT name FROM properties WHERE id = ?', [propertyId], (err, row) => {
          if (err) reject(err);
          else resolve(row);
        });
      });
      if (property) propertyName = property.name;
    }

    const uploadResult = await uploadDocument({
      filePath: req.file.path,
      originalName: fileName,
      mimeType: req.file.mimetype,
      propertyName,
      documentType: aiData?.documentType || 'Other',
      documentDate: aiData?.date,
    });

    driveFileId = uploadResult.fileId;

    // Save to database
    const documentId = await new Promise((resolve, reject) => {
      db.run(
        'INSERT INTO documents (file_name, original_name, mime_type, upload_date, document_date, document_type, amount, currency, property_id, notes, google_drive_id, google_drive_path, ai_analysis_raw) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
        [uploadResult.fileName, fileName, req.file.mimetype, new Date().toISOString(), aiData?.date || null, aiData?.documentType || 'Other', aiData?.amount || null, aiData?.currency || null, propertyId || null, req.body.notes || null, uploadResult.fileId, uploadResult.folderPath, JSON.stringify(parsedResponse)],
        function (err) {
          if (err) reject(err);
          else resolve(this.lastID);
        }
      );
    });

    fs.unlinkSync(req.file.path);

    res.json({
      success: true,
      documentId,
      driveFileId,
      driveLink: getDocumentLink(driveFileId),
      folderPath: uploadResult.folderPath,
      aiData,
      validationErrors: validationResult?.success === false ? validationResult.errors : null,
    });
  } catch (error) {
    logAIFailure(fileName, 'PROCESSING_ERROR', { message: error.message, driveFileId });
    if (fs.existsSync(req.file.path)) fs.unlinkSync(req.file.path);
    res.status(500).json({ error: 'Processing failed', message: error.message, driveFileId });
  }
});

// ============================================================================
// BACKUP
// ============================================================================

app.post('/api/backup/manual', requireAuth, async (req, res) => {
  try {
    const result = await performBackup();
    res.json(result.success ? { success: true, message: 'Backup completed', details: result } : { success: false, error: 'Backup failed', details: result.error });
  } catch (error) {
    res.status(500).json({ success: false, error: 'Backup failed', message: error.message });
  }
});

// ============================================================================
// STARTUP
// ============================================================================

initializeDriveClient();
startBackupScheduler();

app.listen(PORT, () => {
  console.log(`\nðŸš€ ImmoPi Server running on http://localhost:${PORT}`);
  console.log(`âš¡ Ready to accept requests\n`);
});

process.on('SIGTERM', () => {
  console.log('\nðŸ›‘ Shutting down...');
  db.close();
  process.exit(0);
});
